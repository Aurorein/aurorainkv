# aurorainkv
***
本人的本科毕业设计，实现一个分布式KV存储，基于RocksDB实现multi-raft，MVCC分布式事务。

raft部分实现参考[Sakameeee/MIT6.824-Java-2021](https://github.com/Sakameeee/MIT6.824-Java-2021)，我在此基础上将存储引擎改为RocksDB，在raft的基础上改成multi-raft，并实现分布式事务。

仅供学习参考~

raft相关工程实现的资料比较多，这里提一下分布式事务的实现：

percolator事务模型基础
	系统实现了SI快照隔离级别，系统不再是单纯存储某个Key，而是会以快照的方式，将Key和时间戳一起存储，这种方式被称为MVCC（多版本并发控制）。
	系统的事务设计遵循Percolator事务模型，它是一个两阶段提交协议（2PC）。一个事务是一系列写操作的序列。Percolator模型在BigTable的基础上，提供了Snapshot和Isolation语义的分布式事务。系统实现分布式事务主要基于三个组件：Client、TSO、ShardKV事务模块。其中Client是事务的发起者和协调者，包含了传统2PC中的协调者角色。TSO组件是一个为分布式服务器提供精确的、严格单调递增的时间戳服务。ShardKV中的Transaction模块控制与事务存储的信息有关的模块。Transaction模块借助RocksDB的列簇能力，使用不同列簇来存储不同的事务信息类型。系统中使用了三个列簇：default列簇、lock列簇和write列簇。default列簇存储用户原来的value，假设时间戳为ts，则存储在default列簇里面的值为value:ts。lock列簇存储了分布式事务中锁的信息，这个列簇是在分布式事务预写阶段写入的。write列簇写入代表了事务提交的状态，在commit阶段写入。
	Percolator使用lock和write两个列簇来表达事务的状态。Percolator的分布式写事务是由两阶段提交2PC实现的，一个写事务包含多个写操作序列，事务开启时，Client会从TSO组件获取一个时间戳StartTS作为事务作为事务开始的时间。在提交之前，所有的写操作都会缓存在内存里。提交过程包含了预写prewrite阶段和commit阶段，prewrite阶段类似于2PC中的第一阶段提交，percolator算法会从事务的写操作序列中选取一个Key作为primary键，prewrite阶段会优先处理primary键。同样地，commit阶段也会优先处理primary键。Precolator事务模型会通过primary键的lock、write列簇数据来推测事务的执行状态。
4.6.2 两阶段提交
	本节会详细讲解分布式事务两阶段提交的实现。对于每一个事务，系统将事务封装为一个Java对象TwoPhaseCommitter，该对象会负责该事务的两阶段提交的执行过程。该对象封装了事务所用的变量，如TSO组件、primary主键、事务Id、写操作序列列表entries以及事务的一些状态信息。TwoCommitter对象还封装了prewrite、commit、rollback、execute等方法，控制着事务的执行过程。
	TwoPhaseCommitter的prewrite方法协调完成了分布式事务的预写阶段。首先使用了Java异步编排线程池CompletionService，对于用户事务的每一个写操作，通过Client路由到操作的Key所在的节点中进行kvPrewrite RPC调用。kvPrewrite由ShardKV的Transaction层实现，具体逻辑如下：
（1）首先通过RocksDB层接口得到的迭代器RocksDBReader，并创建MvccTxn对象来进行操作事务相关的字段。MvccTxn类提供了对指定RocksDB的default列簇、lock列簇、write列簇的键值对的读、写操作。
（2）通过MvccTxn接口查询指定Key是否有在startTs之后的Write列的记录，如果存在则发生了写写冲突，将此冲突结果返回。TwoPhaseCommitter收到该写写冲突后，会调用rollback方法进行回滚，且停止CompletionService中其它线程的RPC调用的执行。
（3）通过MvccTxn查找是否在lock列簇中存在Key记录，如果存在，这里会有很多可能性。可能有其它事务正在进行提交操作，可能其它事务crash了，lock列没有删除。这里的具体处理逻辑会在故障恢复小节详细讲到。
（4）如果不存在冲突，则会对这个写操作锁定，即在lock列簇写入这个Key的锁数据，并带上startTS时间戳、指向的Primary键和一个超时时间。同时要在default列簇中写入Value数据，同时也要写入startTs时间戳。要写入RocksDB的内容将会加入WriteBatch中，由RocksDB通过事务执行。
	KvPrewrite方法中，通过RocksDBReader查询write和lock列簇的数据并处理时，需要保证write列簇和lock列簇在这区间不会被修改。系统中引入了Latches类，可以对某个Key进行上锁。KvPrewrite方法在开始查询和处理write和lock列簇数据到完成RocksDB的持久化之前，需要通过Latches对要处理的Key进行上锁。通过将锁的粒度控制在Key，尽量避免了阻塞对系统性能的影响。
	TwoPhaseCommitter对所有的Key都完成KvPrewrite阶段后，即完成了对要提交事务写序列的资源锁定，下一步开始执行commit阶段。TwoPhaseCommitter的commit方法中，首先对primary Key进行提交，通过Client路由到指定节点，调用RPC方法kvCommit。KvCommit的逻辑如下：
（1）首先通过RocksDB层接口得到的迭代器RocksDBReader，并创建MvccTxn对象来进行操作事务相关的字段。使用Latches对要处理的Key上锁。
（2）通过MvccTxn查找对应Key在lock列簇的锁数据，如果不存在则会直接返回，TwoPhaseCommitter会将事务回滚。
（3）如果对应Key上存在lock锁资源，则向WriteBatch中加入写write操作和删除lock操作，write操作同时也要标注其Primary键。并通过Raft提交给RocksDB的事务执行接口，以单条事务的方式执行这个WriteBatch。
	Primary Key提交成功后，客户端可以直接返回给用户提交成功。该事务的Secondary键会通过线程池异步地调用kvCommit来执行提交动作。
	TwoPhaseCommitter提供了回滚操作的接口，该操作会对事务操作序列的每一个Key开启单独的线程，使用Client调用RPC接口kvBatchRollback。KvBatchRollback的逻辑如下：
（1）首先通过RocksDB层接口得到的迭代器RocksDBReader，并创建MvccTxn对象来进行操作事务相关的字段。使用Latches对要处理的Key上锁。
（2）找到当前事务对Key的最近Write记录，如果存在则说明已经回滚或者提交了（Write记录的kind决定事务状态是回滚还是提交）。
（3）查找是否存在Key对应的冲突的lock，如果存在则进行roll-forward操作，即删除default列簇的value，并且删除lock列簇的锁数据，写入kind为回滚的write。不存在则直接写入write。以上操作都是通过WriteBatch进行原子执行的。
4.6.3 冲突和故障恢复
	一个事务是否执行成功，只取决于Commit Point。一旦事务的Commit Point确定，所有的写操作都最终必须确定且必须一致地接受。在传统的2PC中，事务的状态是根据协调者可以直接得到的，而Percolator模型需要通过default、lock、write列簇上的事务数据来确定事务状态。本节主要介绍系统如何根据某个事务存储在这三个列簇上的数据来得到事务的提交状态。
	在事务A执行prewrite阶段时，可能会出现lock冲突。如果出现其它事务B的lock与事务A要写的lock发生冲突，可能是以下两种情况：（1）事务B也正在执行，且两个事务的写操作序列之间发生冲突。（2）事务B已发生crash，写入的lock残留未被清理。系统通过事务B的primary key的状态来确定事务的状态。
	具体地，若事务在prewrite阶段执行过程中发生lock冲突，TwoPhaseCommitter会调用RPC方法checkTxnStatus来确定事务目前的状态。checkTxnStatus方法会查找primary key的lock和write列簇数据，有以下几种可能：
（1）write存在，说明该事务已经提交或者回滚。根据write的kind类型可以确定是提交还是回滚。如果write存在将直接返回，不会去判断（2）和（3）。
（2）lock存在，但是Ttl还未超时，此时无法判断事务B是否crash。针对这种情况，TwoPhaseCommitter会等待lock剩余超时时间后重新尝试调用该接口来判断事务状态。
（3）lock存在，且Ttl超时，这时会视此事务发生crash，会直接进行roll-forward操作，将value和lock列簇的数据删除。这里有可能将正常执行的事务误删，因此TwoPhaseCommitter在提交时会确定primary lock是否存在，如果不存在则会直接回滚。
（4）lock和write都不存在，TwoPhaseCommitter认为事务已经回滚，则会对当前Key执行回滚操作。
对于上面的（1）和（4）情况，TwoPhaseCommitter认为需要该事务已经提交或者回滚，它会通过Client调用RPC方法kvResolveLock来获取该事务所有的含有Lock的Key，并做统一的Commit或者Rollback处理。
